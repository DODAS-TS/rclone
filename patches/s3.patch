--- rclone/backend/s3/s3.go	2021-07-29 18:53:44.000000000 +0200
+++ backend/s3/s3.go	2021-07-29 18:53:38.000000000 +0200
@@ -119,6 +119,15 @@
 				Help:  "Get AWS credentials from the environment (env vars or IAM)",
 			}},
 		}, {
+			Name:    "account",
+			Help:    "Get oidc-agent account name",
+			Default: "dodas",
+			Examples: []fs.OptionExample{{
+				Value: "dodas",
+				Help:  "If you can get the token with: oidc-token dodas",
+			},
+			},
+		}, {
 			Name: "access_key_id",
 			Help: "AWS Access Key ID.\nLeave blank for anonymous access or runtime credentials.",
 		}, {
@@ -1318,6 +1327,7 @@
 type Options struct {
 	Provider              string               `config:"provider"`
 	EnvAuth               bool                 `config:"env_auth"`
+	Account               string               `config:"account"`
 	AccessKeyID           string               `config:"access_key_id"`
 	SecretAccessKey       string               `config:"secret_access_key"`
 	Region                string               `config:"region"`
@@ -1503,7 +1513,20 @@
 		SessionToken:    opt.SessionToken,
 	}
 
-	lowTimeoutClient := &http.Client{Timeout: 1 * time.Second} // low timeout to ec2 metadata service
+	cfg := &tls.Config{
+		//ClientCAs: caCertPool,
+		InsecureSkipVerify: true,
+	}
+	//cfg.BuildNameToCertificate()
+
+	tr := &http.Transport{
+		TLSClientConfig: cfg,
+	}
+
+	lowTimeoutClient := &http.Client{
+		Transport: tr,
+		Timeout:   1 * time.Second,
+	} // low timeout to ec2 metadata service
 
 	def := defaults.Get()
 	def.Config.HTTPClient = lowTimeoutClient
@@ -1516,6 +1539,12 @@
 
 	// first provider to supply a credential set "wins"
 	providers := []credentials.Provider{
+		&IAMProvider{
+			stsEndpoint: opt.Endpoint,
+			accountname: opt.Account,
+			httpClient:  def.Config.HTTPClient,
+		},
+
 		// use static credentials if they're present (checked by provider)
 		&credentials.StaticProvider{Value: v},
 
@@ -1542,14 +1571,14 @@
 			ExpiryWindow: 3 * time.Minute,
 		},
 	}
-	cred := credentials.NewChainCredentials(providers)
+	cred := credentials.NewChainCredentials(providers[0:1]) // Enable only IAM
 
 	switch {
 	case opt.EnvAuth:
 		// No need for empty checks if "env_auth" is true
 	case v.AccessKeyID == "" && v.SecretAccessKey == "":
 		// if no access key/secret and iam is explicitly disabled then fall back to anon interaction
-		cred = credentials.AnonymousCredentials
+		// cred = credentials.AnonymousCredentials // Disable anonymous credentials
 	case v.AccessKeyID == "":
 		return nil, nil, errors.New("access_key_id not found")
 	case v.SecretAccessKey == "":
@@ -1568,7 +1597,7 @@
 	awsConfig := aws.NewConfig().
 		WithMaxRetries(0). // Rely on rclone's retry logic
 		WithCredentials(cred).
-		WithHTTPClient(client).
+		WithHTTPClient(getClient(ctx, opt)).
 		WithS3ForcePathStyle(opt.ForcePathStyle).
 		WithS3UseAccelerate(opt.UseAccelerateEndpoint).
 		WithS3UsEast1RegionalEndpoint(endpoints.RegionalS3UsEast1Endpoint)
@@ -1588,7 +1617,10 @@
 		// Enable loading config options from ~/.aws/config (selected by AWS_PROFILE env)
 		awsSessionOpts.SharedConfigState = session.SharedConfigEnable
 		// Set the name of the profile if supplied
-		awsSessionOpts.Profile = opt.Profile
+		// awsSessionOpts.Profile = opt.Profile
+		// The session constructor (aws/session/mergeConfigSrcs) will only use the user's preferred credential source
+		// (from the shared config file) if the passed-in Options.Config.Credentials is nil.
+		awsSessionOpts.Config.Credentials = nil
 	}
 	ses, err := session.NewSessionWithOptions(awsSessionOpts)
 	if err != nil {
